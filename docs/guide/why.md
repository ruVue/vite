# Почему Vite

## Проблемы

До того, как модули ES стали доступны в браузерах, у разработчиков не было встроенного механизма для модульного написания JavaScript. Вот почему мы все знакомы с концепцией "bundling": с использованием инструментов, которые сканируют, обрабатывают и объединяют наши исходные модули в файлы, которые можно запускать в браузере.

Со временем мы увидели такие инструменты, как [webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org) и [Parcel](https://parceljs.org/), что значительно улучшило опыт разработки для разработчиков интерфейса.

Однако по мере того, как мы создаем все более и более амбициозные приложения, объем JavaScript, с которым мы имеем дело, также резко увеличивается. Крупномасштабные проекты нередко содержат тысячи модулей. Мы начинаем сталкиваться с узким местом производительности для инструментов на основе JavaScript: часто может потребоваться неоправданно долгое ожидание (иногда до нескольких минут!) для запуска сервера разработки, и даже при горячей замене модулей (HMR) редактирование файлов может занимать много времени. пару секунд отразиться в браузере. Медленная петля обратной связи может сильно повлиять на продуктивность и удовлетворенность разработчиков.

Vite стремится решить эти проблемы, используя новые достижения в экосистеме: доступность собственных модулей ES в браузере и рост числа инструментов JavaScript, написанных на языках компиляции в родные.

### Медленный запуск сервера

При холодном запуске сервера разработки установка сборки на основе сборщика должна жадно просканировать и собрать все ваше приложение, прежде чем оно сможет быть обслужено.

Vite улучшает время запуска сервера разработки, сначала разделяя модули в приложении на две категории: **dependencies** и **source code**.

- **Dependencies(зависимости)** в основном представляют собой простой JavaScript, который не часто меняется во время разработки. Некоторые большие зависимости (например, библиотеки компонентов с сотнями модулей) также довольно дороги в обработке. Зависимости также могут поставляться в различных форматах модулей (например, ESM или CommonJS).

  Vite [pre-bundles dependencies](./dep-pre-bundling) с помощью [esbuild](https://esbuild.github.io/). esbuild написан на Go и предварительно связывает зависимости в 10-100 раз быстрее, чем сборщики на основе JavaScript.

- **Source code(исходный код)** часто содержит нестандартный JavaScript, который необходимо преобразовать (например, компоненты JSX, CSS или Vue/Svelte), и будет очень часто редактироваться. Кроме того, не весь исходный код нужно загружать одновременно (например, при разделении кода на основе маршрута).

  Vite предоставляет исходный код через [нативный ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). По сути, это позволяет браузеру взять на себя часть работы сборщика: Vite нужно только преобразовывать и обслуживать исходный код по запросу, когда браузер его запрашивает. Код условного динамического импорта обрабатывается только в том случае, если он фактически используется на текущем экране.

<script setup>
import bundlerSvg from '../images/bundler.svg?raw'
import esmSvg from '../images/esm.svg?raw'
</script>
<svg-image :svg="bundlerSvg" />
<svg-image :svg="esmSvg" />

### Медленные обновления

Когда файл редактируется в настройке сборки на основе сборщика, неэффективно перестраивать весь пакет по очевидным причинам: скорость обновления будет снижаться линейно с размером приложения.

В некоторых упаковщиках сервер разработки запускает сборку в памяти, поэтому ему нужно только аннулировать часть своего графа модуля при изменении файла, но ему все равно нужно заново создать весь пакет и перезагрузить веб-страницу. Реконструкция пакета может быть дорогостоящей, а перезагрузка страницы сбрасывает текущее состояние приложения. Вот почему некоторые сборщики поддерживают горячую замену модуля (HMR): позволяя модулю «горячую замену» себя, не затрагивая остальную часть страницы. Это значительно улучшает DX, однако на практике мы обнаружили, что даже скорость обновления HMR значительно ухудшается по мере роста размера приложения.

В Vite HMR выполняется поверх собственного ESM. Когда файл редактируется, Vite нужно только точно аннулировать цепочку между редактируемым модулем и его ближайшей границей HMR (в большинстве случаев только сам модуль), что делает обновления HMR постоянно быстрыми независимо от размера вашего приложения.

Vite также использует заголовки HTTP для ускорения полной перезагрузки страницы (опять же, пусть браузер сделает за нас больше работы): запросы модулей исходного кода обусловливаются с помощью `304 Not Modified`, а запросы модулей зависимостей строго кэшируются с помощью `Cache-Control: max-age=31536000,immutable`, чтобы они больше не попадали на сервер после кэширования.

Как только вы почувствуете, насколько быстр Vite, мы очень сомневаемся, что вы снова захотите мириться с пакетной разработкой.

## Зачем объединять для продакшена

Несмотря на то, что нативный ESM теперь широко поддерживается, поставка разделенного ESM в производственной среде по-прежнему неэффективна (даже с HTTP/2) из-за дополнительных сетевых циклов, вызванных вложенным импортом. Чтобы получить оптимальную производительность загрузки в продакшене, все же лучше связать свой код с встряхиванием дерева, отложенной загрузкой и общим разделением фрагментов (для лучшего кэширования).

Обеспечить оптимальные выходные данные и поведенческую согласованность между сервером разработки и рабочей сборкой непросто. Вот почему Vite поставляется с предварительно настроенной [командой сборки](./build), которая включает множество [оптимизаций производительности](./features#build-optimizations) из коробки.

## Почему бы не связать с esbuild?

Несмотря на то, что `esbuild` работает молниеносно и уже является очень мощным сборщиком для библиотек, некоторые из важных функций, необходимых для объединения _приложений_, все еще находятся в стадии разработки, в частности, разделение кода и обработка CSS. На данный момент Rollup является более зрелым и гибким в этом отношении. Тем не менее, мы не исключаем возможности использования `esbuild` для производственной сборки, когда он стабилизирует эти функции в будущем.

## Чем Vite отличается от X?

Вы можете ознакомиться с разделом [Сравнений](./comparisons) для получения более подробной информации о том, чем Vite отличается от других подобных инструментов.
